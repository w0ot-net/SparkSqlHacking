package cats.kernel;

import scala.Function2;
import scala.Option;
import scala.reflect.ScalaSignature;
import scala.runtime.BoxesRunTime;

@ScalaSignature(
   bytes = "\u0006\u0005\u0005maaB\u0005\u000b!\u0003\r\ta\u0004\u0005\u0006\u0007\u0002!\t\u0001\u0012\u0005\u0006\u0011\u0002!\t%S\u0004\u0006#*A\tA\u0015\u0004\u0006\u0013)A\ta\u0015\u0005\u0006A\u0012!\t!\u0019\u0005\u0006E\u0012!)a\u0019\u0005\u0006o\u0012!\t\u0001\u001f\u0005\n\u0003\u0017!\u0011\u0011!C\u0005\u0003\u001b\u0011!CQ8v]\u0012,GmU3nS2\fG\u000f^5dK*\u00111\u0002D\u0001\u0007W\u0016\u0014h.\u001a7\u000b\u00035\tAaY1ug\u000e\u0001QC\u0001\t\u001e'\u0011\u0001\u0011c\u0006!\u0011\u0005I)R\"A\n\u000b\u0003Q\tQa]2bY\u0006L!AF\n\u0003\u0007\u0005s\u0017\u0010E\u0002\u00193mi\u0011AC\u0005\u00035)\u00111bU3nS2\fG\u000f^5dKB\u0011A$\b\u0007\u0001\t%q\u0002\u0001)A\u0001\u0002\u000b\u0007qDA\u0001B#\t\u0001\u0013\u0003\u0005\u0002\u0013C%\u0011!e\u0005\u0002\b\u001d>$\b.\u001b8hQ\u0019iBeJ\u00197wA\u0011!#J\u0005\u0003MM\u00111b\u001d9fG&\fG.\u001b>fIF*1\u0005K\u0015,U9\u0011!#K\u0005\u0003UM\t1!\u00138uc\u0011!C\u0006\r\u000b\u000f\u00055\u0002T\"\u0001\u0018\u000b\u0005=r\u0011A\u0002\u001fs_>$h(C\u0001\u0015c\u0015\u0019#gM\u001b5\u001d\t\u00112'\u0003\u00025'\u0005!Aj\u001c8hc\u0011!C\u0006\r\u000b2\u000b\r:\u0004HO\u001d\u000f\u0005IA\u0014BA\u001d\u0014\u0003\u00151En\\1uc\u0011!C\u0006\r\u000b2\u000b\rbTh\u0010 \u000f\u0005Ii\u0014B\u0001 \u0014\u0003\u0019!u.\u001e2mKF\"A\u0005\f\u0019\u0015!\rA\u0012iG\u0005\u0003\u0005*\u0011\u0011cQ8n[V$\u0018\r^5wK6{gn\\5e\u0003\u0019!\u0013N\\5uIQ\tQ\t\u0005\u0002\u0013\r&\u0011qi\u0005\u0002\u0005+:LG/\u0001\u0005d_6\u0014\u0017N\\3O)\rY\"\n\u0014\u0005\u0006\u0017\n\u0001\raG\u0001\u0002C\")QJ\u0001a\u0001\u001d\u0006\ta\u000e\u0005\u0002\u0013\u001f&\u0011\u0001k\u0005\u0002\u0004\u0013:$\u0018A\u0005\"pk:$W\rZ*f[&d\u0017\r\u001e;jG\u0016\u0004\"\u0001\u0007\u0003\u0014\u0007\u0011!\u0006\fE\u0002\u0019+^K!A\u0016\u0006\u0003)M+W.\u001b7biRL7-\u001a$v]\u000e$\u0018n\u001c8t!\tA\u0002\u0001\u0005\u0002Z=6\t!L\u0003\u0002\\9\u0006\u0011\u0011n\u001c\u0006\u0002;\u0006!!.\u0019<b\u0013\ty&L\u0001\u0007TKJL\u0017\r\\5{C\ndW-\u0001\u0004=S:LGO\u0010\u000b\u0002%\u0006)\u0011\r\u001d9msV\u0011Am\u001a\u000b\u0003KF\u00042\u0001\u0007\u0001g!\tar\rB\u0005\u001f\r\u0001\u0006\t\u0011!b\u0001?!2q\rJ5l[>\fTa\t\u0015*U*\nD\u0001\n\u00171)E*1EM\u001amiE\"A\u0005\f\u0019\u0015c\u0015\u0019s\u0007\u000f8:c\u0011!C\u0006\r\u000b2\u000b\rbT\b\u001d 2\t\u0011b\u0003\u0007\u0006\u0005\u0006e\u001a\u0001\u001d!Z\u0001\u0003KZD#A\u0002;\u0011\u0005I)\u0018B\u0001<\u0014\u0005\u0019Ig\u000e\\5oK\u0006A\u0011N\\:uC:\u001cW-\u0006\u0002zyR\u0019!0`@\u0011\u0007a\u00011\u0010\u0005\u0002\u001dy\u0012)ad\u0002b\u0001?!)ap\u0002a\u0001w\u0006QQ-\u001c9usZ\u000bG.^3\t\u000f\u0005\u0005q\u00011\u0001\u0002\u0004\u0005\u00191-\u001c2\u0011\rI\t)a_>|\u0013\r\t9a\u0005\u0002\n\rVt7\r^5p]JB#a\u0002;\u0002\u0019]\u0014\u0018\u000e^3SKBd\u0017mY3\u0015\u0005\u0005=\u0001\u0003BA\t\u0003/i!!a\u0005\u000b\u0007\u0005UA,\u0001\u0003mC:<\u0017\u0002BA\r\u0003'\u0011aa\u00142kK\u000e$\b"
)
public interface BoundedSemilattice extends Semilattice, CommutativeMonoid {
   static BoundedSemilattice instance(final Object emptyValue, final Function2 cmb) {
      return BoundedSemilattice$.MODULE$.instance(emptyValue, cmb);
   }

   static BoundedSemilattice apply(final BoundedSemilattice ev) {
      return BoundedSemilattice$.MODULE$.apply(ev);
   }

   static boolean isIdempotent(final Semigroup ev) {
      return BoundedSemilattice$.MODULE$.isIdempotent(ev);
   }

   static boolean isCommutative(final Semigroup ev) {
      return BoundedSemilattice$.MODULE$.isCommutative(ev);
   }

   static Object maybeCombine(final Object x, final Option oy, final Semigroup ev) {
      return BoundedSemilattice$.MODULE$.maybeCombine(x, oy, ev);
   }

   static Object maybeCombine(final Option ox, final Object y, final Semigroup ev) {
      return BoundedSemilattice$.MODULE$.maybeCombine(ox, y, ev);
   }

   // $FF: synthetic method
   static Object combineN$(final BoundedSemilattice $this, final Object a, final int n) {
      return $this.combineN(a, n);
   }

   default Object combineN(final Object a, final int n) {
      if (n < 0) {
         throw new IllegalArgumentException("Repeated combining for monoids must have n >= 0");
      } else {
         return n == 0 ? this.empty() : a;
      }
   }

   // $FF: synthetic method
   static double combineN$mcD$sp$(final BoundedSemilattice $this, final double a, final int n) {
      return $this.combineN$mcD$sp(a, n);
   }

   default double combineN$mcD$sp(final double a, final int n) {
      return BoxesRunTime.unboxToDouble(this.combineN(BoxesRunTime.boxToDouble(a), n));
   }

   // $FF: synthetic method
   static float combineN$mcF$sp$(final BoundedSemilattice $this, final float a, final int n) {
      return $this.combineN$mcF$sp(a, n);
   }

   default float combineN$mcF$sp(final float a, final int n) {
      return BoxesRunTime.unboxToFloat(this.combineN(BoxesRunTime.boxToFloat(a), n));
   }

   // $FF: synthetic method
   static int combineN$mcI$sp$(final BoundedSemilattice $this, final int a, final int n) {
      return $this.combineN$mcI$sp(a, n);
   }

   default int combineN$mcI$sp(final int a, final int n) {
      return BoxesRunTime.unboxToInt(this.combineN(BoxesRunTime.boxToInteger(a), n));
   }

   // $FF: synthetic method
   static long combineN$mcJ$sp$(final BoundedSemilattice $this, final long a, final int n) {
      return $this.combineN$mcJ$sp(a, n);
   }

   default long combineN$mcJ$sp(final long a, final int n) {
      return BoxesRunTime.unboxToLong(this.combineN(BoxesRunTime.boxToLong(a), n));
   }

   static void $init$(final BoundedSemilattice $this) {
   }
}
