package scala.reflect.internal.pickling;

public final class PickleFormat$ {
   public static final PickleFormat$ MODULE$ = new PickleFormat$();
   private static final int MajorVersion = 5;
   private static final int MinorVersion = 2;

   public int MajorVersion() {
      return MajorVersion;
   }

   public int MinorVersion() {
      return MinorVersion;
   }

   public final int TERMname() {
      return 1;
   }

   public final int TYPEname() {
      return 2;
   }

   public final int NONEsym() {
      return 3;
   }

   public final int TYPEsym() {
      return 4;
   }

   public final int ALIASsym() {
      return 5;
   }

   public final int CLASSsym() {
      return 6;
   }

   public final int MODULEsym() {
      return 7;
   }

   public final int VALsym() {
      return 8;
   }

   public final int EXTref() {
      return 9;
   }

   public final int EXTMODCLASSref() {
      return 10;
   }

   public final int NOtpe() {
      return 11;
   }

   public final int NOPREFIXtpe() {
      return 12;
   }

   public final int THIStpe() {
      return 13;
   }

   public final int SINGLEtpe() {
      return 14;
   }

   public final int CONSTANTtpe() {
      return 15;
   }

   public final int TYPEREFtpe() {
      return 16;
   }

   public final int TYPEBOUNDStpe() {
      return 17;
   }

   public final int REFINEDtpe() {
      return 18;
   }

   public final int CLASSINFOtpe() {
      return 19;
   }

   public final int METHODtpe() {
      return 20;
   }

   public final int POLYtpe() {
      return 21;
   }

   public final int IMPLICITMETHODtpe() {
      return 22;
   }

   public final int LITERAL() {
      return 23;
   }

   public final int LITERALunit() {
      return 24;
   }

   public final int LITERALboolean() {
      return 25;
   }

   public final int LITERALbyte() {
      return 26;
   }

   public final int LITERALshort() {
      return 27;
   }

   public final int LITERALchar() {
      return 28;
   }

   public final int LITERALint() {
      return 29;
   }

   public final int LITERALlong() {
      return 30;
   }

   public final int LITERALfloat() {
      return 31;
   }

   public final int LITERALdouble() {
      return 32;
   }

   public final int LITERALstring() {
      return 33;
   }

   public final int LITERALnull() {
      return 34;
   }

   public final int LITERALclass() {
      return 35;
   }

   public final int LITERALenum() {
      return 36;
   }

   public final int LITERALsymbol() {
      return 37;
   }

   public final int SYMANNOT() {
      return 40;
   }

   public final int CHILDREN() {
      return 41;
   }

   public final int ANNOTATEDtpe() {
      return 42;
   }

   public final int ANNOTINFO() {
      return 43;
   }

   public final int ANNOTARGARRAY() {
      return 44;
   }

   public final int SUPERtpe() {
      return 46;
   }

   public final int DEBRUIJNINDEXtpe() {
      return 47;
   }

   public final int EXISTENTIALtpe() {
      return 48;
   }

   public final int TREE() {
      return 49;
   }

   public final int EMPTYtree() {
      return 1;
   }

   public final int PACKAGEtree() {
      return 2;
   }

   public final int CLASStree() {
      return 3;
   }

   public final int MODULEtree() {
      return 4;
   }

   public final int VALDEFtree() {
      return 5;
   }

   public final int DEFDEFtree() {
      return 6;
   }

   public final int TYPEDEFtree() {
      return 7;
   }

   public final int LABELtree() {
      return 8;
   }

   public final int IMPORTtree() {
      return 9;
   }

   public final int DOCDEFtree() {
      return 11;
   }

   public final int TEMPLATEtree() {
      return 12;
   }

   public final int BLOCKtree() {
      return 13;
   }

   public final int CASEtree() {
      return 14;
   }

   public final int ALTERNATIVEtree() {
      return 16;
   }

   public final int STARtree() {
      return 17;
   }

   public final int BINDtree() {
      return 18;
   }

   public final int UNAPPLYtree() {
      return 19;
   }

   public final int ARRAYVALUEtree() {
      return 20;
   }

   public final int FUNCTIONtree() {
      return 21;
   }

   public final int ASSIGNtree() {
      return 22;
   }

   public final int IFtree() {
      return 23;
   }

   public final int MATCHtree() {
      return 24;
   }

   public final int RETURNtree() {
      return 25;
   }

   public final int TREtree() {
      return 26;
   }

   public final int THROWtree() {
      return 27;
   }

   public final int NEWtree() {
      return 28;
   }

   public final int TYPEDtree() {
      return 29;
   }

   public final int TYPEAPPLYtree() {
      return 30;
   }

   public final int APPLYtree() {
      return 31;
   }

   public final int APPLYDYNAMICtree() {
      return 32;
   }

   public final int SUPERtree() {
      return 33;
   }

   public final int THIStree() {
      return 34;
   }

   public final int SELECTtree() {
      return 35;
   }

   public final int IDENTtree() {
      return 36;
   }

   public final int LITERALtree() {
      return 37;
   }

   public final int TYPEtree() {
      return 38;
   }

   public final int ANNOTATEDtree() {
      return 39;
   }

   public final int SINGLETONTYPEtree() {
      return 40;
   }

   public final int SELECTFROMTYPEtree() {
      return 41;
   }

   public final int COMPOUNDTYPEtree() {
      return 42;
   }

   public final int APPLIEDTYPEtree() {
      return 43;
   }

   public final int TYPEBOUNDStree() {
      return 44;
   }

   public final int EXISTENTIALTYPEtree() {
      return 45;
   }

   public final int MODIFIERS() {
      return 50;
   }

   public final int firstSymTag() {
      return 3;
   }

   public final int lastSymTag() {
      return 8;
   }

   public final int lastExtSymTag() {
      return 10;
   }

   private PickleFormat$() {
   }
}
